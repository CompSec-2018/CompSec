# Lab 4: Real-life DDoS incident and malware behind it

### **Important note: You will need provided virtual machine for tasks 2. For task 5 (plugin creation) as well, if you are not ready to set up sandbox by yourself.**

## Background
This exercise is based on real-life incident, which happened some time ago in Finland. One service was target of distributed denial-of-service (DDoS), and was periodically taken down by it.

The attacker had deployed botnet to perform DDoS attack to targeted service. Botnet was created by malicious software, spread by various methods.

The malware which was used to create botnet, had some flaws and some simple weakness was exploited in targeted service, which gives us a good example for researching.

In this exercise you will learn to analyze large-sized log file, and you are able notice how DDoS-attack appears in that log file.

We will take a look for very simple implementation for botnet in demonstration purposes.

Further, we will analyze the software, which was used for creating botnet, by using dynamic and static analysis method.

---
Grading
---
Make a short step-by-step report (what, why and how) of following tasks, and include possible source codes and the most important command line commands used in those tasks. It's recommended to read all tasks before starting. Actual instruction for what to do, is ***in bold and italics*** on each task.

You are elgible to following grades in this exercise by doing tasks as defined. Great ideas and implementations could compensate some poorly implemented ones.
Upper grade requires that all previous ones have been done as well.

It is estimated, that you are able to do Tasks 1 & 2 during lab session (4 hours).

Tasks 3 & 4 are more advanced than earlier ones. Students will have more freedom to implement them. Implementation will probably take time outside of lab.

Task|Grade/Level|Description|
----|:---:|-----------|
 [Task 1](#task-1-finding-traces-of-ddos-attack "Task 1: Finding traces of DDoS attack") | 1 |  Target of distributed denial of service: Analyzing the log file
[Task 2](#wip "Malware: dynamic analysis") | 2-3 | Malware: dynamic analysis
[Task 3](#wip "Malware - static analysis") | 4 | Malware: Static analysis
[Task 4](#wip "Analysis for more complicated samples ") | 5 | Analysis for more complicated samples OR making own analysis tool

Grade 1 can be aquired aswell by doing diary from the corresponding lectures.

Tasks will be reviewed during lab. Unifinished tasks can be returned for defined returning place.

Difficulty on tasks is expected to be raising as you go forward with them.

You should read all instructions, that you know what is happening, and what you actually have to do.

---

## **Prerequisities**

We are using Ubuntu 16.04 virtual machine in this exercise. Location is described on top of Readme of this course repository.
Size of virtual machine is big, because there is another virtual machine inside.

Task 2 **is not** possible to do properly without provided virtual machine. It has some special environment.

Set preferrably 4GB of RAM and all processors for guest (Ubuntu) virtual machine.

Once you have opened the virtual machine, clone course repository into **Desktop**. This location is required and mandatory that some tools are preconfigured correctly.

```
cd ~/Desktop
git clone https://github.com/ouspg/CompSec.git
```


## **Task 1: Finding traces of DDoS attack**
In first task, you will analyze log file of targeted web server.

Usage of different kind of Linux tools are required for successful completion.
Opening a log file in normal text editor potentially leads crashing of virtual machine.

*You will find log file here in the folder [misc](misc) named as anonlog.zip.*
You will need to extract it.

***These Linux commands might help:** grep, less, sort, cut, awk, uniq*

**A)**  Our first mission is to identify timewindow of attack. At what time (in which second) there were the most requests for server? How many requests there were in that moment?

**B)** How servers were actually loaded/burdened? There were multiple requests for server at same time of course, but some weakness of service was also exploited. Requests had some specific functionality.

**C)** At what time attack started? With help of section B. information, you are able to give valid guess. There were actually two episodes for attacks. We want to know earlier one.

**D)** What IP address(es) hypotetically points towards controller of botnet itself?
It can be seperated from any other requests on the server with good reasoning. It actually caused attacker to get caught.

## **Task 2: Malware - dynamic analysis**

*The next task will be quite long and it has been split to multiple phases, but it should give good insight, how the malware was behaving on basic level, based on some analysis*

We have seen some consequences what the controller of botnet was able to produce. How he/she was able to create such a botnet?

The attacker had created multiple versions of Trojan-like software.
Different versions of software was meant to target different groups of users - something what they would install into their machines.

In this case, software was mostly advertised as *Steam Code Generator 2016*; software which would give you any game you want! 
Some versions of the malwares were demostrating generation of Steam  codes, and some were demostrating something else,, and we are examing something else in this exercise.

In this case, malware was *League of Legends - Hacktool*, which was "hided" behind the naming *Steam Code Generator 2016*, so it could be probably advertised as *special* product. You were "able" to produce infinite amount of in-game currency with it.

At this point it might be already clear, that this software was indeed Trojan malware. Intention was not to give free Steam games or in-game currency for League of Legends game, instead software installed something unwanted to your pc, taking total control of it and finally making it part of botnet.

We are going to take a glance for this League of Legends Hacktool by making dynamic analysis for it. But at first, we have to get at least *a little* familiar with tools.

### **A) Testing sandbox**

When you want to analyze malware, you don't usually want to infect your own machine. Instead you want to run it in some safe enviroment. Additionally easy way to undo changes would be helpful if you want to repeat process somewhat easily.

One good solution is to use virtual machines. Snapshot feature allows easy way to get back to situation, where you were before the moment of execution. Modern malwares might even detect virtual environments, and are not working there, but we are ignoring it now.

We might have been using virtual machines already somewhere at this point, but now we are taking this a little bit further. 

We are automating usage of virtual machines, by using tool [F-Secure Sandboxed Execution Environment (SEE)](https://github.com/F-Secure/see)

F-Secure SEE implements Python based core framework for controlling and automating usage of virtual machines, therefore enabling automated execution of malware. In this case, it is opening new virtual machines under our Ubuntu 16.04 virtual machine. (Nested virtual machines)

This enables possibility to inspect virtual machine outside from it: we can capture more some essential data, when compared to just by inspecting from inside virtual machine.

SEE enables automated rollback to the state before execution, therefore we can easily repeat the process and clean anything what program caused to virtual machine.

SEE core does not offer any possibility or tools for actual analysing, instead SEE is totally plugin based, and we are using some essential plugins in later tasks. Now we are just using it to open virtual machine, and just test execution of malware.

We can find example configuration for SEE in [see](see) directory, and we will be using it.

**We stil need to** update hardware-based configurations. That will be achieved by running following command inside [see](see) directory:

```shell
virsh dumpxml win7 > conf/imageInfo/windows7.xml
```
This will regenerate configuration file for running virtual machine, based on host hardware limitations.

With good luck, it should be enough now.


The actual main program (sandbox.py)for SEE is currently blank. 

> **Now, we will follow tutorial presented [here](https://see.readthedocs.io/en/latest/tutorial_hellosandbox.html) to add some code into it, and make it to run our first virtual machine.**

We should try it out at first with the first code example.
Replace filepath in context_factory varibale, with path to [our context file](see/conf/context.json)

Now we can just run:
```shell
python3 sandbox.py
```
At first, it might look like nothing visible happens, but actually there is virtual machine running now on the background. We can check it out, by opening program Virtual Machine Manager from the list of applications.
By clicking the running machine, and then pressing 'Open' button, we can view the machine.

Machine automatically closes in 1 minute.

This virtual machine is based on Windows 7, and it has some preconfigured environment as well, that sandbox can use it. Learning  of it goes out of the scope this execrise. Now we just want to use this environment to analyse things. We are using this machine for running the malware samples.


> **Next, let's add some more functionality for sandbox. Try out second code example provided [in tutorial.](https://see.readthedocs.io/en/latest/tutorial_hellosandbox.html)**

In this case, context configuration file is now given as parameter instead of hardcoding it. We should be able to run it now with command:

```shell
python3 sandbox.py conf/context.json
```

Window for virtual machine should appear now automatically. Additionally, Hello, world! text should appear on the console at the same time, when window appears.

> **Okay, let's add now some custom functionality! It's time to actually do something with virtual machine.**

## B) Dynamic analysis

Dynamical analysis (also known as behavior analysis) of  malware simply means running the malware, and inspecting the underlying system; how this program is behaving in there.

As previously mentioned, if we want to analyze some unknown or unsafe file, we want to do it in some safe environment. In this case, we are using virtual machines, and automating their usage with F-Secure SEE.

The analysis is made with plugins. We are not now intrested how they are actually are working: it might take way too much time. Instead, we are just interested about the results of analysis what they are making.

Plugins are following:

* Network plugin: This enables automated network traffic capture from guest machine, by using [Wireshark](https://www.wireshark.org/). It produces a log file.

* Disk plugin: Based on usage of [libguestfs](http://libguestfs.org/)(with help of [VMinspect](https://github.com/noxdafox/vminspect)) and Qemu. The purpose is to analyze differences on virtual machine disk file on start and on the end of the execution. Shortly, generating a log file, which shows all changes on filesystem from the time virtual machine was turned on. (6mins on average for disk compare analysis on this task, depending on file changes. Be patient.)

* Memory plugin: Based on [Volatility](https://github.com/volatilityfoundation/volatility).  We are generating a dump from the virtual machine RAM, and then analysing it, by using different plugins of Volatility.

* There is also screenshot plugin, but not much use in this case.

Analysing disk changes and getting memory dump from whole machine is not easy to implement from inside virtual machine, and therefore tool which can automate these from outside, could be useful.


### **Running analysis**

Sandbox should be preconfigured and ready-to-go on your virtual machine.

Sandbox is Python3 script. Main program can be found [here.](see/sandbox.py)

The purpose is just to use SEE for creating analysis logs, we are not modifying it.. at least not yet. But if you want, you can add something own there.

It is using Windows 7 image as guest virtual machine for executing the malware sample.

**You are unable to use any other virtual machines** or self configured and installed SEE for this task, because provided virtual machine has special enviroment, and without it we can't get good sample from malware. Simply, malware is not working properly.

If you want to use SEE for something else, here is short [intro.](see/README.md)

Open terminal, and change location to [see](see) folder, where sandbox.py is located.

To run sample, here is example command:

```
$python3 sandbox.py conf/context.json malware/malwares/SteamCodeGenerator/87a4e82bfc2e45e02c9e751e353158a1495ecc60f0e1fc17266bf230f638705b.zip --hooks conf/hook_conf.json --command "7z x {sample} -omalware/ && start  malware\SteamCodeGenerator2016.exe"
```
Short explanation of command:
 1. Path to Main program (sandbox.py)
 2. ARG 1: Path to context configuration. (We are using QEMU Hypervisor for virtualization in this case)
 3. ARG 2: Path to malware, in this case it is Zip file. Only single file allowed
 4. ARG 3: Path to hook(plugins) configuration
 5. ARG 4: Command to be executed in target guest machine. In this case, we are extracting given zip file with 7zip to folder 'malware', and running file SteamCodeGenerator2016.exe after extraction. Filenames here cannot contain any whitespaces, they will not work.

In practise after running the command, following shoud happen:
* SEE should open virtual machine
* Once VM is ready, file is uploaded and executed. Memory and disk snapshot is taken before and after malware execution.
* Then VM is waiting some time, and then closing and cleaning environment
* Samples will be analysed, and logfiles will be produced. Disk analysis takes at least 5 minutes.

## B) Interpret the results

SEE is putting results on configured folders, in this case to following folders: 
* network
* memlogs 
* disklogs

In network folder, you will find .pcap file, which can be read with Wireshark.

In memlogs folder, we have taken three different analysis from memory dumps (before, and after malware execution) Processes, mutants (mutexes) and active network connections before and after malware execution.


In disklogs folder, there is new .json file, which shows all diskchanges on virtual machine.

**Based on these files, answer to following questions:**

* Malware is connecting to some domain, which one?

* Based on analysing network traffic and connections - shortly describe what malware is doing

  * What it did at first with domain?
  * After that, some kind of harmful cycle started. Can you describe it?
  * Describe which details in logfiles gave required information

* Compare start and end logs in memlogs folder

  * What are mutexes in programs, and why are we analysing them?
  * Which new processes were spawned?
  * If you compare mutexes, what are they telling about the program we launched?
  * What are differences in netscans telling?

* Based on disk analysis, can you guess what files malware created? What entries in registry it edited? Why it was useful for malware to edit these entries?



## **Task 4: Malware - static analysis**

Previously we have performed dynamic analysis for malware: inspecting the behavior of the malware by executing it.

Another way for analysing is to perform static analysis - we are not executing the malware, instead we are looking at the file(s) itself.

At first glance, if we haven't got much experience about reverse engineering, we might be seeing just some .exe files, and have no idea how to start.

But with some correct tools, we might see a lot, *particularly* in this case!

Let's see what basic Linux command *file* has to say:

```shell
$ file SteamCodeGenerator2016.exe
SteamCodeGenerator2016.exe: PE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS Windows
```

Looks like that we are probably facing .Net assembly.

One good tool for reversing these kind of executables is [dnSpy.](https://github.com/0xd4d/dnSpy), and we are using it as an example in this case.

It is portable tool, which is fully working assembly editor on Windows environment.
In Linux, we can use some of the properties of it, like console part.
We can decompile executables with it, which is enough for us.

Example for decompiling in Linux environment.
Go to dnSpy root directory:
```shell
mono dnSpy.Console.exe -o your/output/path path/to/your/malware.exe 
```
You will need to install [mono](https://www.mono-project.com) to your enviroment, if you want repeat it on another Linux than the one we have provided.

Once we disassemble these files, we can actually see whole source code as it's written. It might take couple of minutes to compile, depending on file, so patience is required.

Files are not protected at all.

This malware was written in Visual Basic (we can see code as C#) and looks like it has been Microsoft Visual Studio project.

**Now, the intention of this task is to write short report what program is actually doing.** Since we can read program mostly in C#, it shouldn't be hard at all. (In most cases malwares are written in C language or protected somehow, and there we might need to read pure machine instructions instead.)
You are free to use any tools you want, as long as you are not analysing in your host system in unsafe environment. Even though this malware is not dangerous anymore, it's good to have principles.

**Answer at least to these questions in your report:**

### A) What's the role of SteamCodeGenerator.exe, keycrack.exe and steam-dll-pro.exe?

### B) How are they trying to hide their current/upcoming activites?

### C) What's the role of anti-cheat-bypass-tool.exe in Data folder?

* We are particularly interested about this file.
* This file contains actually two additional binaries. What are their names?
* Find a way to reverse these files as well, and include the general purposes of these files as well to your report. Additionally:
  * How bots were controlled? There were at least two ways, describe at least the automatic approach.
  * Some source code or ideas of some common DDoS tools have been used in this malware. Describe three of them, and explain shortly why they are working (and why those technics are sometimes hard to prevent). It's enough to identify tools, you can look information about them elsewhere.
  * Malware actually contains hidden GUI for DDoS tools it is using. Can you find and use it? Describe how you did it.

### D) How well you were able to gather information from malware with dynamic analysis when compared to full reveal from source code?

## Task 5.

Implement **one** of the described following tasks, and make step-by-step report (what,why and how) including source files, for what you did:

* Ever heard about WannaCry malware? In last year (2017), this malware caused a lot of troubles in hospitals and other organisations. This malware was ransomware attack, and encrypted all the importants files of machine. It exploited some vulneralibities, which gave it self-spearding properties, making it a *worm*. Luckily there was a flaw (or intended property), which was so called *kill switch*, and stopped the spreading of malware in the cases, when machine was able to connect internet. Every time when malware was executed, it looked for some domain. Based on result malware did something. 
**In this task, we will take of look for original [*dropper*](https://en.wikipedia.org/wiki/Dropper_(malware)) of WannaCry. Only this specific dropper contained so called kill-switch.**

    * **Your task is to make static analysis for this dropper, and make step-by-step report, how you can find location of domain name of kill-switch. It should not be too hard, since you know that it exists. Explain this function, which contains kill switch.**

    * Explanation contains how you found the URL and therefore the function. What is the logic of this function? How kill-switch worked?
    What other functions are called in this function? Are functions from other library?
    
    * You can use (and it is recommended to use) for example [radare2](https://github.com/radare/radare2) for reverse engineering this executable. In practise, we are disassembling binary to machine instructions, and looking the code of malware in assembly language.
    Radare2 will be used in future as well.

    * Cheatsheet for Radare2 can be found [here.](https://github.com/radare/radare2/blob/master/doc/intro.md) 

* **Make** a very simple plugin/hook for F-secure SEE sandbox, and answer to given questions. The purpose of the plugin is following:

  * Calculate MD5 -, SHA-1 - and SHA-256 hash for given binary(ies) on execution. (Zip file can be calculated as well.)

  * Explain shortly as well, what is the purpose of hashes, and why they have been used. Why we are calculating three different hashes?

  * Use [VirusTotal Public API v2.0](https://www.virustotal.com/en/documentation/public-api/) to get possible existing information from VirusTotal for calculated hashes. In other words. your program is making HTTP request to the API, sending hashes, and storing/showing responses.

  * Send only one hash key. After response, compare if all  calculated hash keys are match for they keys from response, in case there is match for malware (given hash key). Which hash key you chose, and why?

  * Program should make simple log file about results.

  * You can use following API key, if you don't want to create own account: cc36b7771c0c738d7923b3209b6ae6c37a868e9412b3c2dd4109b10bda8f4f6e

  * Note, that requests are limited for 4 per one minute for one public API key, you might need your own account from where you are able to get own key. Just create account, and key can be found from your profile.

  * You have to edit file [hook_conf](see/conf/hook_conf.json) to add your plugin. You can mimic configuration of other plugins.

  * Add your plugin to [hooks folder](see/hooks). Make plugin to inherit [Hook interface](https://github.com/F-Secure/see/blob/master/see/interfaces.py) to get it work.

  * Use your plugin in main program [sandbox.py](see/sandbox.py)

  * **Return plugin file, screenshot of information it provides when running in sandbox/or from logfile it provided, and explanation about hashes. You can explain as comments in plugin file, what you are actually doing in code.**


* **Something interesting** in botnets and malwares, but we haven't dealt with it yet? Feel free to implement and show us what you got.